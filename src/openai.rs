use crate::cli::ProjectType;
use crate::error::CommitSenseError;
use crate::version;
use anyhow::{Context, Result};
use log::{debug, info, warn};
use semver::Version;
use serde::{Deserialize, Serialize};
use openai_api_rs::v1::{api::OpenAIClient as OpenAIApiClient, chat_completion};

// --- Structures for OpenAI API Interaction ---

/// Represents the request body for the Chat Completions API.
#[derive(Serialize, Debug)]
struct ChatCompletionRequest {
    model: String,
    messages: Vec<ChatMessage>,
    temperature: Option<f32>,
}

/// Represents a single message in the chat conversation.
#[derive(Serialize, Deserialize, Debug, Clone)]
struct ChatMessage {
    role: String,
    content: String,
}

/// Represents the overall structure of the response from the Chat Completions API.
#[derive(Deserialize, Debug)]
struct ChatCompletionResponse {
    choices: Vec<ChatCompletionChoice>,
}

/// Represents a single completion choice provided by the model.
#[derive(Deserialize, Debug)]
struct ChatCompletionChoice {
    message: ChatMessage,
}

// --- Structures for CommitSense Logic ---

/// Defines the structure of the JSON object expected in the AI's response content.
#[derive(Deserialize, Serialize, Debug)]
pub struct AISuggestion {
    /// The type of version bump suggested ("major", "minor", "patch", "none").
    #[serde(rename = "bump")]
    pub bump_type: String,
    /// The exact next version string calculated by the AI (e.g., "1.2.3").
    pub next_version: String,
    /// The Markdown formatted changelog points generated by the AI.
    #[serde(rename = "changelog")]
    pub changelog_markdown: String,
}

/// Client for interacting with the OpenAI API.
pub struct OpenAIClient {
    api_key: String,
    api_url: String,
    model: String,
}

impl OpenAIClient {
    /// Creates a new OpenAIClient instance.
    pub fn new(api_key: String, api_url: String, model: String) -> Self {
        OpenAIClient {
            api_key,
            api_url,
            model,
        }
    }

    /// Constructs the prompt messages (system and user) for the OpenAI API call.
    fn build_prompt(
        &self,
        current_version: &str,
        commits: &[String],
        project_type: ProjectType,
    ) -> Vec<ChatMessage> {
        // Format the list of commits for clarity in the prompt
        let commit_list = commits
            .iter()
            .map(|msg| format!("---\n{}\n---", msg.trim()))
            .collect::<Vec<String>>()
            .join("\n\n");

        // Build parts of the system prompt separately to avoid format string issues
        let intro = format!("You are an AI assistant specializing in software versioning and release notes. Your task is to analyze the following git commit messages since the last release (currently version {}) for a {} project.",
            current_version, project_type);

        // Enhanced system prompt with more detailed guidelines and examples
        let system_prompt = format!("{}\n\nBased on the commit messages, determine:\n1. The appropriate semantic version bump type (major, minor, patch, or none)\n2. The exact next version number\n3. A well-formatted changelog in Markdown format\n\nFollow these semantic versioning rules carefully:\n- MAJOR version bump (x.0.0): Reserved for backwards-incompatible API changes, breaking changes, or significant rewrites\n  Example commits: \"BREAKING CHANGE: Remove deprecated API\", \"Complete rewrite of core functionality\"\n- MINOR version bump (0.x.0): For backwards-compatible new features or significant improvements\n  Example commits: \"Add new search functionality\", \"Implement caching system\", \"New CLI option for verbose output\"\n- PATCH version bump (0.0.x): For backwards-compatible bug fixes, performance improvements, or minor changes\n  Example commits: \"Fix null pointer exception\", \"Correct typo in error message\", \"Optimize database query\"\n- NO bump (none): For changes that don't affect the code functionality (docs, tests, CI/CD, refactoring)\n  Example commits: \"Update README\", \"Add unit tests\", \"Configure GitHub Actions\", \"Refactor variable names\"\n\nFor the changelog:\n- Group related changes together (e.g., group all bug fixes)\n- Use clear, concise language focusing on the impact of the change\n- Start each entry with a present-tense verb (Add, Fix, Update, etc.)\n\nReturn your analysis as a JSON object with this exact structure:\n```json\n{{\n  \"bump\": \"major|minor|patch|none\",\n  \"next_version\": \"x.y.z\",\n  \"changelog\": \"- Change 1\\n- Change 2\\n...\"\n}}\n```\n\nYour response should be strictly in this JSON format without any additional text.", intro);

        // Enhanced user prompt with clearer instructions
        let user_prompt = format!(
            "Current version: {}\nProject type: {}\n\nAnalyze these commit messages to determine semantic version changes:\n\n{}\n\nProvide ONLY the requested JSON with bump type, next version, and markdown changelog entries.",
            current_version, project_type, commit_list
        );

        vec![
            ChatMessage {
                role: "system".to_string(),
                content: system_prompt,
            },
            ChatMessage {
                role: "user".to_string(),
                content: user_prompt,
            },
        ]
    }

    /// Calls the OpenAI API, parses the response, validates it, and returns the suggestion.
    pub async fn get_version_and_changelog(
        &self,
        current_version_str: &str,
        commits: &[String],
        project_type: ProjectType,
    ) -> Result<AISuggestion> {
        // Skip API call if no commits to analyze
        if commits.is_empty() {
            info!("No commits to analyze. Returning 'none' bump suggestion.");
            return Ok(AISuggestion {
                bump_type: "none".to_string(),
                next_version: current_version_str.to_string(),
                changelog_markdown: "No changes".to_string(),
            });
        }

        // Parse the current version for validation later
        let current_version = Version::parse(current_version_str).with_context(|| {
            format!(
                "Current version '{}' is not a valid semantic version.",
                current_version_str
            )
        })?;

        // Build the messages for the OpenAI API
        let messages = self.build_prompt(current_version_str, commits, project_type);

        // Convert our messages to the format expected by openai_api_rs
        let api_messages = messages.iter().map(|msg| {
            chat_completion::ChatCompletionMessage {
                role: match msg.role.as_str() {
                    "system" => chat_completion::MessageRole::system,
                    "user" => chat_completion::MessageRole::user,
                    "assistant" => chat_completion::MessageRole::assistant,
                    _ => chat_completion::MessageRole::user, // Default to user for unknown roles
                },
                content: chat_completion::Content::Text(msg.content.clone()),
                name: None,
                tool_calls: None,
                tool_call_id: None,
            }
        }).collect::<Vec<_>>();

        // Log the API request (but not the full prompt which could be large)
        debug!(
            "Sending request to OpenAI API with model {}",
            self.model
        );

        // Build the OpenAI client
        let mut client = OpenAIApiClient::builder()
            .with_api_key(&self.api_key)
            .build()
            .map_err(|e| anyhow::anyhow!("Failed to build OpenAI client: {}", e))?;

        // Create the request
        let req = chat_completion::ChatCompletionRequest::new(
            self.model.clone(),
            api_messages,
        );

        // Make the API request
        let response = client.chat_completion(req).await
            .context("Failed to get chat completion from OpenAI API")?;

        // Extract the assistant's message
        if response.choices.is_empty() {
            return Err(CommitSenseError::Api(
                "OpenAI API returned empty choices array".to_string(),
            )
            .into());
        }

        // Get the content from the first choice
        let assistant_message = match &response.choices[0].message.content {
            Some(content) => content,
            None => return Err(CommitSenseError::Api(
                "OpenAI API returned a message with no content".to_string(),
            ).into()),
        };

        // Extract the JSON block from the message
        let json_block = extract_json_block(assistant_message).ok_or_else(|| {
            CommitSenseError::Api("Could not find a valid JSON block in the API response".to_string())
        })?;

        // Parse the JSON block into our AISuggestion structure
        let mut suggestion: AISuggestion = serde_json::from_str(json_block).with_context(|| {
            format!(
                "Failed to parse AI suggestion JSON. Raw JSON block: {}",
                json_block
            )
        })?;

        // Validate the AI's response
        // 1. Check Bump Type is Valid
        let lower_bump_type = suggestion.bump_type.to_lowercase();
        if !["major", "minor", "patch", "none"].contains(&lower_bump_type.as_str()) {
            return Err(CommitSenseError::Api(format!(
                "Received invalid bump type '{}' from AI. Expected 'major', 'minor', 'patch', or 'none'.",
                suggestion.bump_type
            ))
            .into());
        }
        // Standardize casing for internal use
        suggestion.bump_type = lower_bump_type;

        // 2. Validate Next Version is Parsable as SemVer
        let next_version = Version::parse(&suggestion.next_version).with_context(|| {
            format!(
                "AI suggested next_version '{}' is not a valid semantic version.",
                suggestion.next_version
            )
        })?;

        // 3. Ensure Next Version > Current Version (unless bump is 'none')
        if suggestion.bump_type != "none" {
            if next_version <= current_version {
                return Err(CommitSenseError::Api(format!(
                    "AI suggested next_version '{}' which is not greater than current version '{}', despite bump type being '{}'. AI response may be inconsistent.",
                    suggestion.next_version, current_version_str, suggestion.bump_type
                )).into());
            }
        } else { // Bump type is "none"
            if next_version != current_version {
                warn!(
                    "AI suggested bump type 'none' but next_version '{}' differs from current version '{}'. Correcting next_version to match current version.",
                    suggestion.next_version, current_version_str
                );
                // Override AI's version if bump is 'none' but version changed
                suggestion.next_version = current_version_str.to_string();
            }
        }

        // 4. Optional Consistency Check: Compare AI's next_version with a locally calculated one based on bump_type.
        // This helps detect if the AI followed SemVer increment rules correctly.
        let expected_next =
            version::calculate_expected_version(&current_version, &suggestion.bump_type);
        if suggestion.bump_type != "none" && expected_next != next_version {
            warn!(
                "AI suggested next_version '{}' differs from the version strictly calculated ('{}') based on bump type '{}' and current version '{}'. Proceeding with AI's suggested version, but this might indicate unexpected AI behavior.",
                suggestion.next_version, expected_next, suggestion.bump_type, current_version_str
            );
        }

        info!("AI suggestion validated successfully.");
        Ok(suggestion)
    }
}

/// Helper function to extract a JSON block (`{...}`) from a potentially larger string.
/// Handles cases where the JSON might be embedded within text or markdown code fences.
fn extract_json_block(text: &str) -> Option<&str> {
    // First, try to find JSON within ```json ... ``` markdown fences
    if let Some(start_marker) = text.find("```json") {
        let start_json = start_marker + 7; // Position after ```json
        if let Some(end_marker) = text[start_json..].find("```") {
            let potential_json = text[start_json..start_json + end_marker].trim();
            // Basic check if it looks like a JSON object
            if potential_json.starts_with('{') && potential_json.ends_with('}') {
                debug!("Extracted JSON from ```json block");
                return Some(potential_json);
            }
        }
    }

    // If no markdown block found or it wasn't valid JSON, find the first '{' and last '}'
    if let Some(start) = text.find('{') {
        if let Some(end) = text.rfind('}') {
            if end > start {
                debug!("Extracted JSON by finding first '{{' and last '}}'");
                // Return the substring including the braces
                return Some(&text[start..=end]);
            }
        }
    }

    debug!("Could not find a recognizable JSON block in the text.");
    None // No JSON block found
}